#!/bin/bash

CONFIG_FILE="/revpro/site-configs.conf"
CONF_DIR="/revpro/conf"
LOG_DIR="/revpro/logs"
NGINX_CONF="/etc/nginx/nginx.conf"
AUTHENTIK_PROXY_CONF="/etc/nginx/authentik-proxy.conf"  # Path to the special authentik proxy config

# Store results for table summary
summary_results=()

# Function to create log files and return status
create_log_files() {
    local domain=$1
    local access_log_status="❌"
    local error_log_status="❌"

    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR"
    fi

    if [ -f "$LOG_DIR/${domain}_access.log" ]; then
        access_log_status="✅"
    else
        touch "$LOG_DIR/${domain}_access.log"
        access_log_status="✅"
    fi

    if [ -f "$LOG_DIR/${domain}_error.log" ];then
        error_log_status="✅"
    else
        touch "$LOG_DIR/${domain}_error.log"
        error_log_status="✅"
    fi

    # Return the log status
    echo "$access_log_status $error_log_status"
}

# Function to generate Nginx configuration file with header
generate_nginx_conf() {
    local domain=$1
    local container=$2
    local certificate=$3
    local conf_file="$CONF_DIR/$domain.conf"
    local conf_status="❌"

    mkdir -p "$(dirname "$conf_file")"

    local use_authentik_proxy=false
    local forward_scheme="http"
    local server=""
    local port=""

    # Check if container uses 's:', 'a:', or 'a:s:'
    if [[ "$container" == s:a:* || "$container" == a:s:* ]]; then
        container="${container/s:a:/}"
        container="${container/a:s:/}"
        forward_scheme="https"
        use_authentik_proxy=true
    elif [[ "$container" == s:* ]]; then
        container="${container/s:/}"
        forward_scheme="https"
    elif [[ "$container" == a:* ]]; then
        container="${container/a:/}"
        use_authentik_proxy=true
    fi

    # Extract server (container) and port from the container definition
    server=$(echo "$container" | cut -d':' -f1)
    port=$(echo "$container" | cut -d':' -f2)

    # Write the Nginx configuration file
    cat > "$conf_file" <<EOF
############
# $domain
# autogenerated using >> cmnds revpro
# DON'T EDIT DIRECTLY, revpro OVERWRITES THIS FILE!!!
# github.com/maskalix/cmnds
############

server {
    listen 80;
    server_name $domain;

    # Redirect HTTP to HTTPS
    location / {
        return 301 https://\$host\$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name $domain;

    access_log $LOG_DIR/${domain}_access.log;
    error_log $LOG_DIR/${domain}_error.log;

    # SSL settings
    ssl_certificate /etc/letsencrypt/live/$certificate/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$certificate/privkey.pem;

    # Include optional configuration files
    include /etc/nginx/ssl-ciphers.conf;
    include /etc/nginx/letsencrypt-acme-challenge.conf;

    # Proxy variables
    set \$forward_scheme $forward_scheme;
    set \$server $server;
    set \$port $port;

EOF

    # If using authentik proxy, include the authentik proxy configuration
    if [ "$use_authentik_proxy" = true ]; then
        echo "    # Authentik proxy configuration" >> "$conf_file"
        echo "    include $AUTHENTIK_PROXY_CONF;" >> "$conf_file"
    else
        # If not using authentik proxy, include default location block
        cat >> "$conf_file" <<EOF
    location / {
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$http_connection;
        proxy_http_version 1.1;
        proxy_pass \$forward_scheme://\$server:\$port;
    }
EOF
    fi

    echo "}" >> "$conf_file"  # Close server block

    # Mark the config as successfully written
    if [ -f "$conf_file" ];then
        conf_status="✅"
    fi

    # Create log files and capture their statuses
    log_status=$(create_log_files "$domain")
    access_log_status=$(echo "$log_status" | awk '{print $1}')
    error_log_status=$(echo "$log_status" | awk '{print $2}')

    # Store the result for the summary
    summary_results+=("$domain | $conf_status | $access_log_status | $error_log_status")
}

# Function to clean up old Nginx configurations
cleanup_old_configs() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "Configuration file not found at $CONFIG_FILE"
        return
    fi

    local valid_domains=$(awk '{print $1}' "$CONFIG_FILE")

    # Loop through existing configuration files
    find "$CONF_DIR" -type f -name "*.conf" | while read -r conf_file; do
        domain=$(basename "$conf_file" .conf)
        if ! echo "$valid_domains" | grep -q "^$domain$"; then
            echo "Removing old configuration for $domain"
            rm "$conf_file"
        fi
    done
}

# Function to clean logs and configuration directories
clean_directories() {
    echo "Cleaning up $CONF_DIR and $LOG_DIR..."

    # Remove and recreate the conf directory
    if [ -d "$CONF_DIR" ]; then
        rm -rf "$CONF_DIR"
    fi
    mkdir -p "$CONF_DIR"

    # Remove and recreate the logs directory
    if [ -d "$LOG_DIR" ]; then
        rm -rf "$LOG_DIR"
    fi
    mkdir -p "$LOG_DIR"

    echo "Both $CONF_DIR and $LOG_DIR have been cleaned and recreated."
}

# Function to reload Nginx inside the Docker container
reload_nginx() {
    echo "Reloading Nginx..."
    
    # Check the Nginx configuration syntax before reloading
    docker compose exec -T reverseproxy nginx -t
    if [ $? -ne 0 ]; then
        echo "Nginx configuration test failed, please check the errors above."
        return 1
    fi

    # Reload Nginx, specifying the config file explicitly if necessary
    docker compose exec -T reverseproxy nginx -c /etc/nginx/nginx.conf -s reload || echo "Failed to reload Nginx, please check the container status and logs."
}

# Function to restart Nginx
restart_nginx() {
    docker container restart reverseproxy
    echo "Nginx restarted."
}

# Function to add a new site configuration from command-line arguments
add_site_config() {
    local domain=$1
    local container=$2
    local certificate=$3

    # Create the new Nginx config for this domain
    generate_nginx_conf "$domain" "$container" "$certificate"

    # Reload Nginx to apply changes
    reload_nginx
}

# Function to open the configuration file in a text editor (nano)
edit_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "Configuration file not found at $CONFIG_FILE"
        exit 1
    fi

    nano "$CONFIG_FILE"
}

# Function to list all domains from the configuration file
list_domains() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "Configuration file not found at $CONFIG_FILE"
        exit 1
    fi

    echo "Listing all domains from $CONFIG_FILE:"
    awk '{print $1}' "$CONFIG_FILE"
}

# Main script logic
case "$1" in
    generate)
        # Check if CONFIG_FILE exists before attempting to parse it
        if [ ! -f "$CONFIG_FILE" ]; then
            echo "Configuration file not found at $CONFIG_FILE"
            exit 1
        fi

        # Generate configurations from the configuration file
        while IFS=$'\t ' read -r domain container certificate; do
            # Skip lines starting with #
            [[ "$domain" =~ ^#.*$ ]] && continue
            generate_nginx_conf "$domain" "$container" "$certificate"
        done < "$CONFIG_FILE"

        # Print the summary table
        echo -e "\nDomain | Conf | Acc-log | Err-log"
        echo "-------------------------------"
        for result in "${summary_results[@]}"; do
            echo "$result"
        done
        ;;
    clean)
        # Clean logs and configuration directories
        clean_directories
        ;;
    reload)
        # Reload Nginx to apply changes
        reload_nginx
        ;;
    restart)
        # Restart Nginx
        restart_nginx
        ;;
    add)
        # Add new site configuration from command-line arguments
        if [[ "$#" -ne 3 ]]; then
            echo "Usage: $0 add <domain> <container> <certificate>"
            exit 1
        fi
        add_site_config "$2" "$3" "$4"
        ;;
    edit)
        # Open config file for editing
        edit_config
        ;;
    list)
        # List all domains from the configuration file
        list_domains
        ;;
    *)
        echo "Usage: $0 {generate|clean|reload|restart|add|edit|list}"
        exit 1
        ;;
esac
